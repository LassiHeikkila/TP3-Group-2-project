	\section{Data Handling}
	
		\subsection{Data Structures}
	
		In order to simplify the passing of pertinent data to and from sub-functions, two structs were created. Structs - or records - are a type of data structure which can hold an arbitrary number of fields, each of which can be of a different data type. This makes them ideal for this case; arrays of type \lstinline|double| are required to hold the system to be solved and the gradient components of the electric field, \lstinline|int| variables can be used to hold the dimensions of the array - which allows the solver to simply read this information rather than calculate it when needed - and to pass back the number of iterations required to meet the desired convergence, and the \lstinline|bool| data type can be used to write-protect boundary elements. This final point is discussed in detail in section~\ref{sec:mask}.
		
		\subsection{Implementation}
		
		In the case of \lstinline|eStatics|, a global pointer to the data struct was defined as \lstinline|extern| in the header file and created outside the main function. This allows the designation of a memory address to the structure which can be seen by all sub-routines, allowing each to read from and write to the fields contained within it. The \lstinline|new| command is used to dynamically assign memory to those fields, and expand them when needed. This allows systems of arbitrary size, or fineness of grid, to be solved by the software package. Another benefit of using a global struct is that variables such as system dimension, desired convergence, and maximum iterations need only be written once when building the system - from then on only memory reads are required. Finally, having only one set of data to be passed by address lowers RAM overhead due to there being no need to copy data and pass it by value to a sub-routine.
	
	\section{Element Protection}
	\label{sec:mask}
		
		A problem with iterative algorithms such as the Finite Difference Method (FDM) is that the initial boundary conditions can be eroded by successive averaging. To counteract this, these boundaries must either be rewritten with each iteration - with significant costs in terms of time due to extra read/write cycles being required, and RAM overheads due to a copy of the initial grid having to be kept in memory - or write-protected for the duration of the program. For the latter, which can avoid or reduce the noted costs of the former, the boolean data type is ideally suited.
		
		\subsection{Boolean Mask}
		
		Boolean is a data type with only two possible values; true or false. As such, each boolean - or \lstinline|bool| - requires very little memory. Typically, a boolean variable is the smallest possible variable in terms of RAM requirements. This makes them ideal for use in the write-protection of boundary elements, as it drastically lowers the overhead in this area. In order to utilise this, a boolean array of equal dimension to the system array is created whilst the user-provided bitmap image is being analysed. If an element, or pixel, of the system is defined as a boundary element the corresponding element in the boolean mask is set to true. All non-boundary elements are set to false.
		
		Next, whilst the solver is running through the system array point-by-point, it first checks the corresponding element in the mask. If this boolean is found to be true, the solver ignores that element. This saves time, as no further calculation needs to take place on that element.
	
		\subsection{Convergence Locking}
		
			Another benefit of having a boolean mask is that it allows `convergence locking' - wherein points that have already converged within a user-defined threshold are locked by setting their corresponding element in the boolean mask to true. This means that this point will be ignored in subsequent iterations, thus cutting down on time and iterations required. As the system overall converges on a solution more and more of the elements will be locked, meaning the solver has fewer calculations to perform per iteration. This effectively introduces adaptive grid sizing - although not adaptive grid spacing - to the software package, as the `to-be-solved' grid shrinks with each iteration. It may have costs, however, as some points may lock too early due to initially slow-to-converge elements being mistaken for those which have already converged. This risk is lowered by considering the overall rate of change of convergence, whereby the total number of converged points per iteration is stored. Invariably, this rate of change is negative as it takes a few iterations for all points in the grid to be reached by averaging. Once the rate of change is positive - that is, total converged points is higher than on the previous iteration - the locking mechanism is engaged.
	
	\section{Parallelisation}
	
		Benefit of checkerboard updating. Explain why - independence of same-coloured points.
		
		\subsection{Hardware Concurrency}
		
			Talk about cores and threads, and how the program 
		
		\subsection{Thread Pool Pattern}
		
			Talk about creation/deletion overheads and why a thread pool negates these.
