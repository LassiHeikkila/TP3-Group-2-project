		A problem with iterative algorithms such as the Finite Difference Method (FDM) is that the initial boundary conditions can be eroded by successive averaging. To counteract this, these boundaries must either be rewritten with each iteration - with significant costs in terms of time due to extra read/write cycles being required, and RAM overheads due to a copy of the initial grid having to be kept in memory - or write-protected for the duration of the program. For the latter, which can avoid or reduce the noted costs of the former, the boolean data type is ideally suited.
		
		\subsubsection{Boolean Mask}
		
		Boolean is a data type with only two possible values; true or false. As such, each boolean - or \lstinline|bool| - requires very little memory. Typically, a boolean variable is the smallest possible variable in terms of RAM requirements. This makes them ideal for use in the write-protection of boundary elements, as it drastically lowers the overhead in this area. In order to utilise this, a boolean array of equal dimension to the system array is created whilst the user-provided bitmap image is being analysed. If an element, or pixel, of the system is defined as a boundary element the corresponding element in the boolean mask is set to true. All non-boundary elements are set to false.
		
		Next, whilst the solver is running through the system array point-by-point, it first checks the corresponding element in the mask. If this boolean is found to be true, the solver ignores that element. This saves time, as no further calculation needs to take place on that element.
	
		\subsubsection{Convergence Locking}
		
			Another benefit of having a boolean mask is that it allows `convergence locking' - wherein points that have already converged within a user-defined threshold are locked by setting their corresponding element in the boolean mask to true. This means that this point will be ignored in subsequent iterations, thus cutting down on time and iterations required. As the system overall converges on a solution more and more of the elements will be locked, meaning the solver has fewer calculations to perform per iteration. This effectively introduces adaptive grid sizing - although not adaptive grid spacing - to the software package, as the `to-be-solved' grid shrinks with each iteration. It may have costs, however, as some points may lock too early due to initially slow-to-converge elements being mistaken for those which have already converged. This risk is lowered by considering the overall rate of change of convergence, whereby the total number of converged points per iteration is stored. Invariably, this rate of change is negative as it takes a few iterations for all points in the grid to be reached by averaging. Once the rate of change is positive - that is, total converged points is higher than on the previous iteration - the locking mechanism is engaged.
